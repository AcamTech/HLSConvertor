/* Autogenerated with kurento-module-creator */

#include <gst/gst.h>
#include "MediaPipeline.hpp"
#include "MediaPipelineImpl.hpp"
#include <HLSConvertorImplFactory.hpp>
#include "HLSConvertorImpl.hpp"
#include <jsonrpc/JsonSerializer.hpp>
#include <KurentoException.hpp>

#define GST_CAT_DEFAULT kurento_hlsconvertor_impl
GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
#define GST_DEFAULT_NAME "KurentoHLSConvertorImpl"

namespace kurento
{
namespace module
{
namespace hlsconvertor
{

HLSConvertorImpl::HLSConvertorImpl (const boost::property_tree::ptree &config, std::shared_ptr<MediaPipeline> mediaPipeline)  : FilterImpl (config, std::dynamic_pointer_cast<MediaPipelineImpl> (mediaPipeline))
{

  std::shared_ptr<MediaPipelineImpl> pipe;
  pipe = std::dynamic_pointer_cast<MediaPipelineImpl> (getMediaPipeline() );
  gchar *name;
  GstElement* sampleplugin;
//  GstCaps *c = NULL;
  name = gst_element_get_name(element);
//  GST_WARNING_OBJECT(element, "output_object");
  GST_DEBUG ("@rt HLSConvertor Working Here = %s, element name=%s", getName ().c_str (), name);

  g_object_set (element, "filter-factory", "hlsconvertor", NULL);
  g_object_get (G_OBJECT (element), "filter", &sampleplugin, NULL);
  g_object_get (G_OBJECT(element), "filter-factory", &name, NULL);
  GST_DEBUG("@rt filter-factory is %s", name);
  int type;
  g_object_get (G_OBJECT(element), "type", &type, NULL);
  GST_DEBUG("@rt filter-type is %d", type);
  if (sampleplugin == NULL) {
    GST_DEBUG ("Media Object not avialable");
    throw KurentoException (MEDIA_OBJECT_NOT_AVAILABLE,
                            "Media Object not available");
  }

//  g_object_unref (sampleplugin);
/*
  g_object_get (G_OBJECT (element), "video-caps", c, NULL);
  if (c == NULL) {
    GST_LOG ("@rt video-caps no available");
  } else {
    GST_LOG ("@rt video-caps is %s", gst_caps_to_string(c) );
  }

  if (!GST_IS_ELEMENT (element)) {
    GST_DEBUG ("@rt element checking GST_IS_ELEMENT (element) failed.");
  }  
*/
//  GstElement *queue = gst_bin_get_by_name(GST_BIN(element), "queue");
  GstPad* vsPad;
  vsPad = gst_element_get_static_pad(element, "src");
  if (vsPad == NULL) {
    GST_DEBUG("@rt can not get sink pad from element-bin.");
  }
  GstElement* sink = gst_bin_get_by_name(GST_BIN(element), "agnosticbin0");
//  GstElement *sink = gst_bin_get_by_name(GST_BIN(element), "sink");
  if (sink == NULL) {
    GST_DEBUG("@rt can not get agnosticbin0 from element-bin.");
  } else {
    gst_element_set_state(sink, GST_STATE_NULL);

//  gst_element_unlink(queue, sink);
//    gst_bin_remove(GST_BIN(element), sink);

    g_object_unref(sink);
  }

  sink = gst_element_factory_make("filesink", "sink@rt");
  if (sink == NULL) {
    GST_DEBUG("@rt can not make filesink element.");
  } else {
    vsPad = gst_element_get_static_pad(sink, "sink");
    if (vsPad == NULL) {
      GST_DEBUG("@rt can not get sink pad from filesink element.");
    }
 
//    gst_element_set_locked_state (element, TRUE);
//    gst_element_set_state (element, GST_STATE_NULL);
//    gst_bin_remove (GST_BIN ( pipe->getPipeline() ), element);

//    g_object_set(G_OBJECT(sink), "location", "/var/log/kurento-media-server/location", NULL);
    g_object_set(G_OBJECT(sink), "append", TRUE, NULL);
//    if (!gst_bin_add (GST_BIN ( pipe->getPipeline() ), sampleplugin)) GST_DEBUG("@rt pipeline add element failed.");;
//    if (!gst_bin_add (GST_BIN ( pipe->getPipeline() ), sink)) GST_DEBUG("@rt pipeline add sink failed.");;
    if (!gst_bin_add (GST_BIN ( element ), sink)) GST_DEBUG("@rt pipeline add sink failed.");;
    if (!gst_element_link(sampleplugin, sink)) GST_DEBUG("@rt link element and sink failed.");
//    element = sink;
  }
//@  gst_bin_add(GST_BIN(element), sink);

//  GstPad* sinkPad;
/*
  sinkPad = gst_pad_new("sink_video", GST_PAD_SINK);
  gst_element_add_pad(element, sinkPad);
*/
//@  gst_element_sync_state_with_parent(sink);
//  gst_element_link(queue, sink);

    //GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(g_pipeline));
    //gst_element_set_bus(sink, bus);
    //gst_object_unref(bus);

  // gst_element_set_state(sink, GST_STATE_PLAYING);
  // gst_element_set_state(element, GST_STATE_PLAYING);

  // g_object_unref(queue);
/*
  sinkPad = gst_element_get_static_pad(element, "sink_video");
  if (sinkPad == NULL) {
    GST_DEBUG("@rt can not get static sink_video pad.");
  } else {
    g_object_get (G_OBJECT (sinkPad), "location", &name, NULL);
    GST_DEBUG("@rt sinkPad's location=%s", name);
  }
*/
  GST_DEBUG ("@rt FileSink init finished.");

}

MediaObjectImpl *
HLSConvertorImplFactory::createObject (const boost::property_tree::ptree &config, std::shared_ptr<MediaPipeline> mediaPipeline) const
{
  return new HLSConvertorImpl (config, mediaPipeline);
}

HLSConvertorImpl::StaticConstructor HLSConvertorImpl::staticConstructor;

HLSConvertorImpl::StaticConstructor::StaticConstructor()
{
  GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, GST_DEFAULT_NAME, 0,
                           GST_DEFAULT_NAME);
}

} /* hlsconvertor */
} /* module */
} /* kurento */
